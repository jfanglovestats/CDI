---
title: "Clustering Deviation Index (CDI) Tutorial"
author:
  - "Jiyuan Fang"
  - "Jichun Xie"
package: CDI
date: "Last updated: Jun 1st 2023"
output:
    BiocStyle::html_document:
        toc: true
        toc_float: true
vignette: >
  %\VignetteIndexEntry{Clustering Deviation Index (CDI) Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


```{r setup, include = FALSE}
library(CDI)
```

# Introduction

This tutorial shows how to apply CDI to select optimal clustering labels among different candidate cell labels for UMI counts of single-cell RNA-sequencing dataset. Sections 1-3 are for datasets from one batch; Section 4 is for datasets from multiple batches. Datasets used in this tutorial were simulated for illustration purpose. 

# Installation

CDI can be installed from Bioconductor:

```{r, eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("CDI")
```

The latest version can be installed from Github:

```{r, eval = FALSE}
if (!requireNamespace("remotes", quietly = TRUE))
    install.packages("remotes")
remotes::install_github("jichunxie/CDI", build_vignettes = TRUE) 
```

# Load datasets

CDI provides simulated toy single-cell RNA-seq UMI count matrices for illustration purpose. To use other datasets, please change the code in the following two blocks. Filtering of cells/genes can be applied before feature gene selection; normalization/imputation is not applicable here, as CDI models the raw UMI counts. 

**Inputs**:

- **one_batch_matrix**: a single-cell RNA-seq UMI count matrix from one batch (each row represents a gene and each column represent a cell). To apply CDI to datasets from multiple batches, please check section 4. 
- **one_batch_matrix_label_df**: the label sets of the one_batch_matrix, where each row represents a cell, and each column represents a set of cell labels generated by existing clustering methods such as K-Means. 
- **one_batch_matrix_celltype**: a vector of characters indicating the benchmark cell types of cells in one_batch_matrix (not necessary except for evaluation purpose).


```{r, data_reading}
data(one_batch_matrix, package = "CDI")
dim(one_batch_matrix)

data(one_batch_matrix_celltype, package = "CDI")
table(one_batch_matrix_celltype)
```

Here we provide 12 label sets generated from PCA$+$KMeans and Seurat v3.1.5, where the number of clusters range from 2 to 7. 

For better visualization and comparison, the column names of this data frame indicate the clustering method and the number of clusters. For example, "KMeans_k5" refers to the set of cell labels generated by KMeans with 5 clusters. 

```{r, data_label}
data(one_batch_matrix_label_df, package = "CDI")
knitr::kable(head(one_batch_matrix_label_df[,c("KMeans_k2", "KMeans_k4", "Seurat_k2", "Seurat_k3")], 3))
```


# Select feature genes with `feature_gene_selection`

Feature genes are those genes that express differently across cell types. Several methods are available for feature gene selection. Here we propose a new method called working dispersion score (WDS). We select genes with highest WDS as the feature genes.

```{r, feature_selection}
feature_gene_indx <- feature_gene_selection(
	X = one_batch_matrix, 
	batch_label = NULL, 
	method = "wds", 
	nfeature = 500)
sub_one_batch_matrix <- one_batch_matrix[feature_gene_indx,]
```

# `calculate_CDI`

First, calculate the size factor of each gene with `size_factor`. The output of `size_factor` will be one of the inputs of `calculate_CDI`. 

```{r}
one_batch_matrix_size_factor <- size_factor(X = one_batch_matrix)
```

Second, calculate CDI for each candidate set of cell labels:

```{r, calculate_cdi1}
start_time <- Sys.time()
CDI_return1 <- calculate_CDI(
	X = sub_one_batch_matrix, 
	cand_lab_df = one_batch_matrix_label_df, 
	batch_label = NULL, 
	cell_size_factor = one_batch_matrix_size_factor)
end_time <- Sys.time()
print(difftime(end_time, start_time))
```



# Select the optimal label set with minimum CDI-AIC/CDI-BIC

```{r}
knitr::kable(CDI_return1)
```

CDI counts the number of unique characters in each label set as the "N_cluster". If the column names of label set data frame are provided with the format "[ClusteringMethod]_k[NumberOfClusters]" such as "KMeans_K5, `calculate_CDI` will extract the "[ClusteringMethod]" as the Cluster_method. The clustering method can also be provided in the argument `clustering_method` for each label set. 


The outputs of `calculate_CDI` include CDI-AIC and CDI-BIC. CDI calculates AIC and BIC of cell-type-specific gene-specific NB model for UMI counts, where the cell types are based on each candidate label set, and only the selected subset of genes are considered. Whether to use CDI-AIC or CDI-BIC depend on the goals. We suggest using CDI-BIC to select optimal main cell types and using CDI-AIC to select optimal subtypes, because BIC puts more penalty on the complexity of models (number of clusters). 

**Output visualization** 

The outputs of CDI are demonstrated with a lineplot. The x-axis is for the number of clusters. The y-axis is for the CDI values. Different colors represent different clustering methods: The orange line represents label sets from Seurat; the blue line represents label sets from K-Means. The red triangle represents the optimal clustering result corresponding to the smallest CDI value.

The cell population in this simulated dataset doesn't have a hierarchical structure. We use CDI-BIC to select the optimal set of cell labels. The label set "KMeans_k5" has the smallest CDI-BIC and is selected as the optimal. 

```{r}
CDI_lineplot(cdi_dataframe = CDI_return1, cdi_type = "CDI_BIC")
```

A benchmark label set refers to human annotated cell type label set from biomarkers for real data or true label set for simulated data. If such label set is available, we can also compare the optimal clustering label set selected by CDI with it. Here we provide the heatmap of contingency table between benchmark label set and the optimal clustering label set selected by CDI. Each row represents a cell type in the benchmark label set, and each column represents a cluster in the optimal clustering label set selected by CDI. Each rectangle is color-scaled by the proportion of the cells in the given cluster coming from the benchmark types. Each column sums to 1. 

```{r}
contingency_heatmap(benchmark_label = one_batch_matrix_celltype,
	candidate_label = one_batch_matrix_label_df$KMeans_k5,
	rename_candidate_clusters = TRUE,
	candidate_cluster_names = paste0('cluster', seq_len(length(unique(one_batch_matrix_label_df$KMeans_k5)))))
```

We can also calculate the CDI for the benchmark label set as the following:

```{r}
benchmark_return1 <- calculate_CDI(X = sub_one_batch_matrix,
	cand_lab_df = one_batch_matrix_celltype, 
	batch_label = NULL, 
	cell_size_factor = one_batch_matrix_size_factor)
```

The results of benchmark label set can be added to the CDI lineplot:

```{r}
CDI_lineplot(cdi_dataframe = CDI_return1,
	cdi_type = "CDI_BIC",
	benchmark_celltype_cdi = benchmark_return1,
	benchmark_celltype_ncluster = length(unique(one_batch_matrix_celltype)))
```

The purple star represents the CDI value for the benchmark label set. The result shows that the benchmark label set achieves lowest CDI-BIC among all label sets. Therefore, if the benchmark label set is available as one candidate label set, it will be selected by CDI-BIC as the optimal. 

# Apply CDI to datasets from multiple batches

CDI accepts datasets from multiple batches. The candidate label sets can be obtained after batch effect correction, but CDI will be calculated based on raw UMI count matrices. The procedure of applying CDI to multi-batch datasets is similar to that of one batch, except for one extra input of batch labels. 

## Inputs:
  
- **two_batch_matrix**: a single-cell RNA-seq UMI count matrix from the multiple batches (each row represents a gene and each column represent a cell).
- **two_batch_matrix_batch**: a vector of characters indicating the batch labels of cells in two_batch_matrix. The number of batches can be greater than 2.
- **two_batch_matrix_label_df**: the label sets of the two_batch_matrix, where each row represents a cell, and each column represents a label set generated by existing clustering methods such as K-Means after batch effect correction.
- **two_batch_matrix_celltype**: a vector of characters indicating the benchmark cell types of cells in two_batch_matrix (not necessary unless for evaluation purpose).


## Data loading
  
```{r, data_reading2}
data(two_batch_matrix_celltype, package = "CDI")
table(two_batch_matrix_celltype)

data(two_batch_matrix_batch, package = "CDI")
table(two_batch_matrix_batch)

data(two_batch_matrix, package = "CDI")
dim(two_batch_matrix)

```


```{r, data_label2, out.width="70%"}
data(two_batch_matrix_label_df, package = "CDI")
knitr::kable(head(two_batch_matrix_label_df[,c("KMeans_k5", "KMeans_k6", "Seurat_k5", "Seurat_k6")], 3))
```

## Feature gene selection

```{r, feature_selection2}
feature_gene_indx <- feature_gene_selection(
	X = two_batch_matrix,
	batch_label = two_batch_matrix_batch,
	method = "wds",
	nfeature = 500)
sub_two_batch_matrix <- two_batch_matrix[feature_gene_indx,]
```

## Calculate CDI

```{r}
two_batch_matrix_size_factor <- size_factor(two_batch_matrix)

start_time <- Sys.time()
CDI_return2 <- calculate_CDI(
	X = sub_two_batch_matrix,
	cand_lab_df = two_batch_matrix_label_df, 
	batch_label = two_batch_matrix_batch,
	cell_size_factor = two_batch_matrix_size_factor)
end_time <- Sys.time()
print(difftime(end_time, start_time))
```




```{r}
knitr::kable(CDI_return2)
```



Calculate the benchmark label set (if available) CDI:
  
```{r}
benchmark_return <- calculate_CDI(
	X = sub_two_batch_matrix,
	cand_lab_df = two_batch_matrix_celltype,
	batch_label = two_batch_matrix_batch,
	cell_size_factor = two_batch_matrix_size_factor)
```

Output visualization:
  
```{r}
CDI_lineplot(cdi_dataframe = CDI_return2,
	cdi_type = "CDI_BIC",
	benchmark_celltype_cdi = benchmark_return,
	benchmark_celltype_ncluster = length(unique(two_batch_matrix_celltype))) 
```

Compare the optimal clustering label set selected by CDI with the benchmark cell type labels:

```{r}
contingency_heatmap(
	benchmark_label = two_batch_matrix_celltype,
	candidate_label = two_batch_matrix_label_df$Seurat_k5,
	rename_candidate_clusters = TRUE,
	candidate_cluster_names = paste0('cluster', seq_len(length(unique(one_batch_matrix_label_df$Seurat_k5)))))
```

# Session Information

```{r}
sessionInfo()
```

